Category,SubCategory,Task
LangChain Agents,Arxiv Retrieval,"Create a system that retrieves relevant documents from Arxiv.org based on user input queries related to topics such as Physics, Mathematics, Computer Science, Quantitative Biology, Quantitative Finance, Statistics, Electrical Engineering, and Economics."
LangChain Agents,Search Engine Integration,"Develop a conversational agent that utilizes a search engine API (e.g., Tavily Search) to provide comprehensive and accurate responses to user queries about current events or recent information. The system should seamlessly integrate the search engine functionality into the conversation flow, allowing users to ask questions and receive relevant information."
LangChain Agents,Function Specification Generation,"Develop methods to generate function specifications compatible with OpenAI Functions API from Python functions or Pydantic models. These specifications should include information such as function name, description, and parameters."
LangChain Agents,JSON Generation,"Implement a method to generate JSON output from the provided data according to specific schema requirements. The JSON output should contain information extracted from an article, specifically focusing on papers mentioned in the text. If no papers are mentioned, an empty list should be returned. The output should adhere strictly to the provided schema, including paper titles and optional author information."
LangChain Agents,Question Condensation and Answer Generation,"Develop a system that condenses a conversation along with a follow-up question into a standalone question, considering the context provided by the conversation. Additionally, design a system that utilizes retrieved passages to answer user questions, ensuring each answer is accompanied by the citation of the source document. The system should prompt the user to cite the source name of the passages used for answering."
LangChain Agents,Question Answering with Context,"Develop a system that can answer questions based solely on provided context. The system should utilize various retrieval strategies, such as typical RAG, parent vector store, hypothetical question vector store, and summary vector store, to retrieve relevant information for answering questions effectively. The system should prompt the user with a context and a question, and generate an answer accordingly."
LangChain Agents,Conversational Search and Answer,"Develop a conversational search and answer system that can retrieve relevant documents and generate responses based on user input questions and chat history. The system should utilize a vector store, such as Pinecone, for document retrieval. It should also be capable of condensing chat history and follow-up questions into standalone questions. The system should prompt users with context and questions, generating answers accordingly."
LangChain Agents,Conversational Search and Answer with Document Retrieval,"Develop a conversational search and answer system that integrates document retrieval from a vector store using Pinecone. The system should be capable of processing chat history and follow-up questions, condensing them into standalone questions, and generating responses based on the provided context and questions."
LangChain Agents,Conversational Agent with Document Search,"Develop a conversational agent with integrated document search functionality using DuckDuckGoSearchRun. The agent should process chat history and questions, format them appropriately, and utilize the ChatAnthropic model for generating responses. Additionally, the agent should handle parsing errors and provide verbose output during execution."
LangChain Agents,Conversational Agent with Document Compression and Re-ranking,"Develop a conversational agent with integrated document compression and re-ranking functionality using the ContextualCompressionRetriever with CohereRerank. The agent should retrieve a set of documents from a Pinecone vector store, compress them contextually, and then re-rank the compressed documents. It should prompt the user to answer questions based on the compressed context and provide responses using the ChatOpenAI model. The agent should accept questions as input."
LangChain Agents,Query Generation with Reciprocal Rank Fusion,"Create a system that generates queries using the ChatOpenAI model with a temperature of 0. The queries are obtained from a prompt pulled from the 'langchain-ai/rag-fusion-query-generation' hub. The generated queries are then used to retrieve documents from a Pinecone vector store named 'rag-fusion'. These retrieved documents are subjected to reciprocal rank fusion to produce reranked results."
LangChain Agents,Point Expansion from Skeleton,"Create a system that expands a skeleton for answering a question. The system prompts the user to provide a skeleton for the question. The skeleton should be in the form of a numbered list of points, with each point being very short (3∼5 words). After receiving the skeleton, the system continues the writing of each point in the skeleton, with each point being expanded into 1∼2 sentences. The expanded points are then concatenated to form a comprehensive answer."
LangChain Agents,Shopping Assistant with Ionic Tool,"Develop a shopping assistant agent that utilizes an Ionic tool for product recommendation. The agent interacts with users to help them find the best product based on their input. It employs the ChatOpenAI model with a specified temperature for generating responses. The agent is designed to accept user input and maintain a chat history, providing assistance based on the conversation context."
LangChain Agents,Assistance Agent with Robocorp Integration,"Create an assistance agent with integrated Robocorp functionality for executing actions based on user requests. The agent utilizes the ChatOpenAI model with a specific temperature setting for generating responses. It interacts with users to provide assistance and performs actions using the Action Server Toolkit from Robocorp. The agent is designed to accept user input and return corresponding outputs."
LangChain Agents,Content Decomposition Assistant,"Develop a content decomposition assistant that takes complex text input and decomposes it into clear and simple propositions. The agent interacts with users to prompt for input and then utilizes the ChatOpenAI model, specifically configured with the 'gpt-3.5-turbo-16k' model, to generate decomposed propositions. The input is structured as a compound sentence or paragraph, and the agent breaks it down into simpler sentences while maintaining original phrasing whenever possible. Named entities accompanied by additional descriptive information are separated into distinct propositions. The output is presented as a list of strings formatted in JSON, each representing a decomposed proposition. The agent handles cases where no propositions can be generated by providing empty proposals."
LangChain Agents,Python Code Checker and Submitter,"Develop a Python code checker and submitter agent that ensures provided Python code adheres to the ruff, black, and *strict* mypy standards. The agent interacts with users using a ChatOpenAI model configured with the 'gpt-4-1106-preview' model. It prompts users to provide complete, end-to-end Python code, ensuring it meets the specified description/requirements. The agent checks the code using ruff and mypy, and if it encounters any issues, it returns error messages. Once the code passes the checks, the agent strips Python markdown tags, submits the code using the 'submit-code' tool, and returns the submitted code. The agent provides configurable alternatives for different ChatOpenAI models, including 'gpt-4' and 'gpt-3.5-turbo', allowing flexibility in model selection. The input to the agent is a string representing the Python code, and the output is a string representing the submitted code."
LangChain Agents,Book Recommendation Chatbot,"Develop a book recommendation chatbot that interacts with users based on a dataset of books with blurbs. The agent loads a dataset of books from a CSV file ('data/books_with_blurbs.csv'), parses the data, and stores it in memory. The agent utilizes CohereEmbeddings to embed the book titles and sets up a Chroma vector store using the embedded titles. The agent prompts users to provide context and a message. Based on the provided message, the agent retrieves relevant books using the book titles as queries from the Chroma vector store. It then passes the retrieved books and the user's message to a question-answering model (specified by the 'chat' function) configured with a prompt template that includes the context and user's message. The agent returns the response generated by the question-answering model, formatted as a bulleted list of book titles prefixed by a relevant message. The input to the agent includes the user's context and message, and the output is a formatted list of book recommendations."
LangChain Agents,Solo Performance Prompting Agent,"Create a solo performance prompting agent that utilizes the OpenAI language model. The agent accepts questions as input and interacts with users in a conversational manner. It integrates DuckDuckGoSearchRun as a tool to render text descriptions. The agent prompts users with a conversational prompt, utilizing the rendered text descriptions of the tools included. The agent stops processing the input when encountering '</tool_input>' or '</final_answer>'. The output is parsed and returned to the user. The input to the agent includes the user's question, and the output is the response generated by the agent."
LangChain Agents,Answer Generation Agent,"Develop an answer generation agent that utilizes the ChatOpenAI model. The agent interacts with users to answer questions based on contextual information retrieved from Nike's financial 10k filings dataset. It uses HuggingFaceEmbeddings for embedding text and Redis for vector storage, connecting to a pre-loaded index specified by INDEX_NAME, INDEX_SCHEMA, and REDIS_URL. The agent prompts users with a ChatPromptTemplate, incorporating context from the dataset along with the user's question. It then retrieves relevant context using Redis, processes the input, generates an answer using the ChatOpenAI model, and parses the output. The input to the agent includes the user's question, and the output is the generated answer."
LangChain Agents,File Processing Agent,"Develop a file processing agent that interacts with users to process base64 encoded files. The agent utilizes the ChatOpenAI model with temperature set to 0 and model set to 'gpt-4' for generating responses. Users provide base64 encoded files to the agent, along with parameters such as the number of plates, rows, and columns. The agent loads the file, creates a prompt based on the provided parameters, and formats th
LangChain Agents,Chat with PII Detection,"Develop a chat agent with built-in personally identifiable information (PII) detection. The agent uses the ChatOpenAI model for generating responses and the Presidio Analyzer Engine for detecting PII in the user's input. The chat agent simulates a conversation between a user and the agent, with the agent speaking like a pirate. It prompts users with a ChatPromptTemplate, including the chat history and the user's input. The chain first detects PII in the user's input using the Presidio Analyzer Engine. If PII is detected, the agent responds with a message indicating inability to answer questions involving PII. Otherwise, it proceeds with the standard conversation chain. The final chain includes logic to route based on whether PII is detected."
LangChain Agents,Translate Statement with Profanity Guardrails,"Develop an agent to translate a statement into English while ensuring that the translation is free of profanity using guardrails. The agent uses the GuardrailsOutputParser to enforce the guardrails specified in the rail string. The rail string defines a guardrail for the output string 'translated_statement' to ensure it is profanity-free. The PromptTemplate prompts the user to translate the given statement into English, and the chain includes the ChatOpenAI model for translation and the GuardrailsOutputParser to enforce the guardrail. The final chain is configured with the GuardrailsOutputParser's output type as 'dict'."
LangChain Agents,Elasticsearch Query and Chat,"Develop an agent to query Elasticsearch for index information based on user input and provide a response using ChatOpenAI model. The agent uses Elasticsearch to connect to a cloud-hosted Elasticsearch instance, retrieves index information for specified indices (e.g., 'customers'), prompts the user for input using a DSL prompt, utilizes a ChatOpenAI model for generating a response, and employs SimpleJsonOutputParser to parse the JSON output. The ChainInputs class provides typed inputs for the playground with input and top_k parameters."
LangChain Agents,Python DataFrame Exploration and Query,"Create an agent that allows exploration and querying of a pandas DataFrame in Python. The agent uses a ChatOpenAI model to prompt the user with information about the DataFrame, provides a tool for searching persons by name, and enables running Python code snippets using a Python AST REPL tool. The agent executes the provided code snippet on the DataFrame and returns the output. The PythonInputs class defines the input schema for the playground with a query parameter."
LangChain Agents,Chat Bot,Evaluate the effectiveness of a chat bot's responses without explicit user feedback. The chat bot employs an AI model to generate responses and evaluates the effectiveness of its responses based on subsequent user interactions. It formats the dialogues up to the current message and grades the AI's previous response using an LLM (Large Language Model) based on the subsequent user response. If no chat history is present or if the last run ID is missing, appropriate comments are provided. The chat bot accepts inputs including previous chat messages, the user's latest query, and the run ID of the last run.
Langchain Agents,World Knowledge Expert,Create an agent that serves as an expert in world knowledge. The agent's task is to paraphrase a given question into a more general one that is easier to answer. It employs a Few Shot Chat Message Prompt Template to generate examples for paraphrasing questions. The agent utilizes DuckDuckGoSearchAPIWrapper to retrieve context for both the original and paraphrased questions. The agent then uses ChatOpenAI model for generating a comprehensive response to the original question, incorporating relevant context if available. The response should be comprehensive and non-contradictory. The agent accepts user questions and generates paraphrased questions, retrieves context, and provides answers accordingly.
Langchain Agents,Question Answering and Search Query Improvement,Develop an agent that answers users' questions based on provided context and suggests better search queries for web search engines. The agent utilizes DuckDuckGoSearchAPIWrapper to retrieve context for the given question. It prompts the user to provide additional context if necessary and generates a comprehensive answer to the question. Additionally, the agent suggests improved search queries for web search engines to answer the question more effectively. The agent employs ChatOpenAI model for generating responses and prompts. It accepts user questions and provides answers along with suggestions for improved search queries.
Langchain Agents,SQL Query Generation and Natural Language Response,Develop an agent that generates SQL queries based on user questions and provides natural language responses based on the SQL query results. The agent utilizes an LLM (Large Language Model) downloaded from Ollama to process user queries and responses. It interacts with an SQL database to retrieve table schema information and execute SQL queries. The agent prompts the user to provide questions and generates corresponding SQL queries based on the provided table schema. It then executes the SQL queries and prompts the user to provide natural language responses based on the SQL query results. The agent stores conversation history in memory to provide context for subsequent interactions.
LangChain Agents,Document Summarization and Question Answering,Develop an assistant capable of summarizing tables and text documents and answering questions based on the summarized content. The assistant utilizes a ChatOpenAI model to generate concise summaries of tables and text chunks extracted from documents. It categorizes document elements into tables and text chunks, then prompts the user to provide a concise summary for each element. The assistant employs a MultiVectorRetriever to index and retrieve the summarized content. It indexes the summaries using Chroma vectorstore and stores the parent documents in memory. The assistant further utilizes a RAG (Retrieval-Augmented Generation) pipeline to answer questions based on the summarized content. It prompts the user to provide a question based on the provided context, including text and tables, then generates an answer using the ChatOpenAI model. The assistant accepts user questions and provides answers based on the summarized content of the documents.
LangChain Agents,Retrieval-Augmented Generation,Develop an agent capable of answering user questions based on context provided by a RAG (Retrieval-Augmented Generation) model. The agent loads data from a file containing output from a GPT-based web crawler, which includes HTML content of web pages along with their titles and URLs. It splits the HTML content into smaller chunks using a RecursiveCharacterTextSplitter to improve retrieval efficiency. The agent then adds the split content to a vector database using Chroma, which utilizes OpenAI embeddings. It retrieves relevant context from the vector database based on user queries and prompts the user to provide a question based on the retrieved context. Finally, the agent uses a ChatOpenAI model to generate an answer to the user's question. The agent accepts user questions and provides answers based on the retrieved context.
LangChain Agents,Pirate Speak Translator,Develop an agent capable of translating user input into pirate speak. The agent prompts the user to provide text input and translates it into pirate speak using a ChatOpenAI model. The agent accepts user input and provides the translated text in pirate speak.
LangChain Agents,Question Answering Assistant,Develop an agent that assists users in answering questions by utilizing a combination of language model responses and tools. The agent prompts the user to input their question and interacts with them via a chat interface. It maintains a chat history and a scratchpad for intermediate steps. The agent retrieves relevant tools based on the user's input, formats them into OpenAI-compatible functions, and incorporates them into the response generation process. Finally, the agent executes the response generation process using a ChatOpenAI model and presents the generated response to the user.
LangChain Agents,Task Revision,Implement a process to revise the output of a language model to correct errors based on Pydantic validation rules. The process should take a user query as input and generate an initial response. Then, it should validate the response using Pydantic against a predefined schema. If the response contains errors, the process should prompt for revisions until the response satisfies the validation rules or the maximum number of revision attempts is reached. The process should handle up to 10 revision attempts with a default of 5 attempts.
Langchain Agents, Research Report Generation, Develop a system for generating detailed research reports based on provided text prompts. The system should be able to produce well-structured, informative reports with a minimum length of 1,200 words. It should utilize ChatOpenAI models to generate the report content and adhere to specific formatting and citation guidelines. The system should offer configurable options for generating different types of reports, including research reports, resource bibliography recommendations, and research report outlines. Additionally, it should provide prompts for user input and interact with users to gather necessary information for report generation.
JSON Generation,Novel Character Generation,"Generate a JSON object including Lord of the Rings characters such as Frodo Baggins, Gandalf, Aragorn, Legolas, and Gimli. Include their physical description, personality traits, relationships, and notable achievements."
JSON Generation,Fantasy World Building,"Create a JSON representation of a fantasy world, complete with its geography, history, races, cultures, magic systems, and major landmarks."
JSON Generation,Sci-Fi Character Creation,"Develop a JSON object containing characters from a science fiction universe, such as Captain Kirk, Spock, James T. Kirk, Jean-Luc Picard, and Data from Star Trek. Include their species, role, personality, and notable technologies."
JSON Generation,Historical Figure Representation,"Construct a JSON object representing historical figures like Leonardo da Vinci, Cleopatra, Julius Caesar, Joan of Arc, and Napoleon Bonaparte. Include their biographical information, achievements, notable events, and impact on history."
JSON Generation,Superhero Profile Creation,"Generate a JSON object for superhero characters like Superman, Batman, Wonder Woman, Spider-Man, and Iron Man. Include their powers, weaknesses, secret identities, allies, and adversaries."
JSON Generation,Mythical Creature Description,"Create a JSON representation of mythical creatures such as dragons, unicorns, phoenixes, mermaids, and griffins. Include their origin stories, physical attributes, abilities, habitats, and cultural significance."
JSON Generation,Fictional Universe Overview,"Develop a JSON structure detailing the overall universe of a fictional franchise like Marvel Comics, DC Comics, Star Wars, or the Game of Thrones series. Include major events, factions, worlds, and key characters."
JSON Generation,Video Game Character Profile,"Generate a JSON object containing characters from popular video games such as Mario, Link, Master Chief, Lara Croft, and Sonic the Hedgehog. Include their backstory, abilities, companions, and enemies."
JSON Generation,Dystopian Society Description,"Construct a JSON representation of a dystopian society, outlining its government structure, societal norms, technology level, class divisions, and key figures."
JSON Generation,Fairytale Character Background,"Create a JSON object for fairytale characters like Cinderella, Snow White, Little Red Riding Hood, Rapunzel, and the Big Bad Wolf. Include their story arcs, moral lessons, motivations, and outcomes."
Agentic Framework,Intermediate Thoughts,"Return a JSON object with <reasoning> as intermediate reasoning step and <response> as final answer to a user query"
Agentic Framework,Intermediate Thoughts,"Return a JSON object with {'<ACTION>': '<REASONING>'} as intermediate reasoning step and {'<ACTION>': '<REASONING>'} as final answer to a user query"
Agentic Framework,Advanced Actions,"Return a JSON object with {'<ACTION>': '<REASONING>'} as an advanced action and {'<ACTION>': '<RESULT>'} as the outcome"
Agentic Framework,Advanced Actions,"Return a JSON object with {'<ACTION>': {'parameters': '<PARAMETERS>', 'reasoning': '<REASONING>'}} as an advanced action and {'<ACTION>': '<RESULT>'} as the outcome"
Agentic Framework,Decision Making,"Return a JSON object with {'<DECISION>': '<REASONING>'} as the decision and {'<DECISION>': '<RESULT>'} as the outcome"
Agentic Framework,Decision Making,"Return a JSON object with {'decision': '<DECISION>', 'reasoning': '<REASONING>'} as the decision and {'<DECISION>': '<RESULT>'} as the outcome"
Agentic Framework,Problem Solving,"Return a JSON object with {'problem': '<PROBLEM>', 'solution': '<SOLUTION>'} for a given problem and solution"
Agentic Framework,Problem Solving,"Return a JSON object with {'problem': '<PROBLEM>', 'solution': '<SOLUTION>', 'steps': ['<STEP_1>', '<STEP_2>', ...]} for a given problem and solution with intermediate steps"
Agentic Framework,Adaptation,"Return a JSON object with {'context': '<CONTEXT>', 'adaptation': '<ADAPTATION>'} as a response to a changing context"
Agentic Framework,Adaptation,"Return a JSON object with {'context': '<CONTEXT>', 'adaptation': {'reasoning': '<REASONING>', 'action': '<ACTION>'}} as a response to a changing context with reasoning and action"
Agentic Framework,Plan Generation,"Return a JSON object with a plan for action and evidence-based reasoning leading to a final answer."
Agentic Framework,Agent Creation,"Return a JSON object with agent's 'role', 'objectives', and 'goals': {"Role", "Objectives", "Goals"}"
Agentic Framework,Plan Generation,"Return a JSON object with a plan that includes thought process, criticism, and subsequent action: {"Thought", "Criticism", "Action"}"
Simulacrum Agent,Agent Behavior,"Return a JSON object with a typical agent's routine task process such as memory & retrieval, reflection, planning & reacting: {"perceive", "retrieve", "reflect", "plan", "execute"}
Simulacrum Agent,Memory Retrieval,"Return a JSON object for memory retrieval with scoring components: {""recency"": """", ""importance"": """", ""relevance"": """"}"
Simulacrum Agent,Reflection,"Return a JSON object for agent reflection with observation synthesis: {""questions"": [""q1"",""q2""], ""insights"": [""i1"", ""i2""], ""citations"": [1, 5, 8]}"
Simulacrum Agent,Planning,"Return a JSON object for agent planning over time: {""short_term"":[], ""long_term"":[]}"
Simulacrum Agent,Coordination,"Return a JSON object for agent coordination: {""agent1"": {}, ""agent2"": {}, ""shared_goal"": """", ""coordination_events"": []}"
Simulacrum Agent,Information Diffusion,"Return a JSON object for information diffusion: {""original_agent"": "", ""origin_event"": "", ""diffused_events"": []}"
Simulacrum Agent,Reflection Tree,"Return a JSON object representing an agent's tree of reflections with leaf nodes as base observations and non-leaf nodes as higher-level, more abstract thoughts: {""leaf_nodes"": [""observation1"", ""observation2""], ""non_leaf_nodes"": {""level2_thought"": [""leaf_node1"", ""leaf_node2""], ""level3_thought"": [""level2_thought""]]}}"
Simulacrum Agent,Spatial Memory Subgraph,"Return a JSON object representing the part of the world perceived by the agent with root, child, and leaf nodes: {""root"": {""cafe"": {""table"": ""state"", ""chair"": ""state""}, ""park"": {""bench"": ""state""}}, ""houses"": {""house1"": {""bedroom"": {""bed"": ""state""}}}}}"
Simulacrum Agent,Sandbox Environment,"Return a JSON object representing the sandbox world as a tree with areas and objects: {""areas"": {""park"": {""objects"": {""bench"": {}, ""fountain"": {}}}}, ""houses"": {""house1"": {""rooms"": {""bedroom"": {""objects"": {""bed"": {}, ""closet"": {}}}}}}}}}"
Simulacrum Agent,Perception,"Return a JSON object describing the agent perceiving its environment: {"perceive": ""}"
Simulacrum Agent,Memory Retrieval,"Return a JSON object describing the agent retrieving relevant memories: {"retrieve": ""}"
Simulacrum Agent,Reflection,"Return a JSON object describing the agent reflecting on its experiences: {"reflect": ""}"
Simulacrum Agent,Planning,"Return a JSON object describing the agent making plans based on its state: {"plan"": ""}"
Simulacrum Agent,Execution,"Return a JSON object describing the agent executing its planned actions: {"execute"": ""}"
Simulacrum Agent,Perceive,"Generate a JSON object for perceiving events happening around the persona. The schema of input to the function is: {""maze"": ""<Maze instance>"", ""att_bandwidth"": <int>, ""retention"": <int>}"
Simulacrum Agent,Retrieve,"Generate a JSON object for retrieving related events and thoughts based on the perceived events. The schema of input to the function is: {""perceived"": [<ConceptNode>]}"
Simulacrum Agent,Plan,"Generate a JSON object for conducting short and long term planning for the persona. The schema of input to the function is: {""maze"": ""<Maze instance>"", ""personas"": {""<persona_name>"": ""<Persona instance>""}, ""new_day"": <Boolean|String>, ""retrieved"": {<retrieved_data>}}"
Simulacrum Agent,Execute,"Generate a JSON object for executing the agent's current plan. The schema of input to the function is: {""maze"": ""<Maze instance>"", ""personas"": {""<persona_name>"": ""<Persona instance>""}, ""plan"": ""<target_action_address>""}"
Simulacrum Agent,Reflect,"Generate a JSON object for reviewing the persona's memory and creating new thoughts based on it. The schema of input to the function is: {}"
Simulacrum Agent,Move,"Generate a JSON object for the main cognitive function of the agent where the main sequence is called. The schema of input to the function is: {""maze"": ""<Maze instance>"", ""personas"": {""<persona_name>"": ""<Persona instance>""}, ""curr_tile"": [<x_coordinate>, <y_coordinate>], ""curr_time"": ""<datetime instance>""}"
Simulacrum Agent,Open Conversation Session,"Generate a JSON object for opening a conversation session for the persona with specified conversation mode. The schema of input to the function is: {""convo_mode"": ""<conversation_mode>""}"
Simulacrum Agent,Concept Nodes - Perception,"Generate a JSON object for perceiving concept nodes. The schema of input to the function is: {""maze"": {""type"": ""Maze instance""}, ""att_bandwidth"": {""type"": ""integer""}, ""retention"": {""type"": ""integer""}}"
Simulacrum Agent,Concept Nodes - Retrieval,"Generate a JSON object for retrieving related concept nodes based on the perceived concept nodes. The schema of input to the function is: {""perceived"": {""type"": ""array"", ""items"": {""$ref"": ""#/definitions/ConceptNode""}}}"
Simulacrum Agent,Memory Nodes - Planning,"Generate a JSON object for conducting planning based on memory nodes. The schema of input to the function is: {""maze"": {""type"": ""Maze instance""}, ""personas"": {""type"": ""object"", ""additionalProperties"": {""$ref"": ""#/definitions/Persona""}}, ""new_day"": {""anyOf"": [{""type"": ""boolean""}, {""type"": ""string""}]}, ""retrieved"": {""type"": ""object"", ""additionalProperties"": {""type"": ""object""}}}"
Simulacrum Agent,Memory Nodes - Execution,"Generate a JSON object for executing plans based on memory nodes. The schema of input to the function is: {""maze"": {""type"": ""Maze instance""}, ""personas"": {""type"": ""object"", ""additionalProperties"": {""$ref"": ""#/definitions/Persona""}}, ""plan"": {""type"": ""string""}}"
Simulacrum Agent,Memory Nodes - Reflection,"Generate a JSON object for reflecting on memory nodes. The schema of input to the function is: {}"
Simulacrum Agent,Memory Nodes - Movement,"Generate a JSON object for performing movements based on memory nodes. The schema of input to the function is: {""maze"": {""type"": ""Maze instance""}, ""personas"": {""type"": ""object"", ""additionalProperties"": {""$ref"": ""#/definitions/Persona""}}, ""curr_tile"": {""type"": ""array"", ""items"": {""type"": ""integer""}}, ""curr_time"": {""type"": ""string"", ""format"": ""date-time""}}"
Simulacrum Agent,Memory Nodes - Conversation,"Generate a JSON object for initiating conversation sessions based on memory nodes. The schema of input to the function is: {""convo_mode"": {""type"": ""string""}}"
simulacrum Agent,Persona Hyperparameters - Vision Parameters,Define vision parameters for a persona,vision_r: integer; att_bandwidth: integer; retention: integer
simulacrum Agent,World Information - Perceived World State,Define variables to represent the perceived state of the world,curr_time: datetime; curr_tile: tuple; daily_plan_req: str
simulacrum Agent,Persona Identity - Personal Information,Define variables representing the core identity of a persona,name: str; first_name: str; last_name: str; age: int
simulacrum Agent,Reflection Variables - Concept Forgetting and Reflection Configuration,Define variables related to concept forgetting and reflection,concept_forget: int; daily_reflection_time: int; daily_reflection_size: int; overlap_reflect_th: int; kw_strg_event_reflect_th: int; kw_strg_thought_reflect_th: int
simulacrum Agent,New Reflection Variables - Additional Reflection Configuration,Define additional variables for reflection,recency_w: int; relevance_w: int; importance_w: int; recency_decay: float; importance_trigger_max: int; importance_trigger_curr: int; importance_ele_n: int; thought_count: int
simulacrum Agent,Persona Planning - Daily Requirements,Define variables for the persona's daily requirements,daily_req: list[str]; f_daily_schedule: list[list[str,int]]; f_daily_schedule_hourly_org: list[list[str,int]]
simulacrum Agent,Current Action - Current Action Details,Define variables representing the current action being performed by the persona,act_address: str; act_start_time: datetime; act_duration: int; act_description: str; act_pronunciatio: str; act_event: tuple
simulacrum Agent,Chatting - Conversation Details,Define variables representing ongoing conversations,chatting_with: str; chat: list[list[str,str]]; chatting_with_buffer: dict; chatting_end_time: datetime
simulacrum Agent,Path Planning - Planned Path,Define variables for planned path execution,act_path_set: bool; planned_path: list[tuple[int,int]]
simulacrum Agent,Cognitive Modules - Conversation Generation,Generate summarized ideas for agent conversation,generate_agent_chat_summarize_ideas(init_persona, target_persona, retrieved, curr_context) -> JSON
simulacrum Agent,Cognitive Modules - Conversation Generation,Generate summarized relationship for agent conversation,generate_summarize_agent_relationship(init_persona, target_persona, retrieved) -> JSON
simulacrum Agent,Cognitive Modules - Conversation Generation,Generate agent chat,generate_agent_chat(maze, init_persona, target_persona, curr_context, init_summ_idea, target_summ_idea) -> JSON
simulacrum Agent,Cognitive Modules - Conversation Generation,Generate one utterance for agent conversation,generate_one_utterance(maze, init_persona, target_persona, retrieved, curr_chat) -> JSON
simulacrum Agent,Cognitive Modules - Conversation Generation,Generate agent chat v2,agent_chat_v2(maze, init_persona, target_persona) -> JSON
simulacrum Agent,Cognitive Modules - Thought Generation,Generate summarized ideas for persona thought,generate_summarize_ideas(persona, nodes, question) -> JSON
simulacrum Agent,Cognitive Modules - Thought Generation,Generate next line for conversation,generate_next_line(persona, interlocutor_desc, curr_convo, summarized_idea) -> JSON
simulacrum Agent,Cognitive Modules - Thought Generation,Generate inner thought for persona,generate_inner_thought(persona, whisper) -> JSON
simulacrum Agent,Cognitive Modules - Event Generation,Generate action-event triple description,generate_action_event_triple(act_desp, persona) -> JSON
simulacrum Agent,Cognitive Modules - Event Generation,Generate poignancy score,generate_poig_score(persona, event_type, description) -> JSON
simulacrum Agent,Cognitive Modules - History Management,Load history via whisper,load_history_via_whisper(personas, whispers) -> JSON
simulacrum Agent,Cognitive Modules - Conversation Session,Open conversation session in analysis mode,open_convo_session(persona, convo_mode) -> JSON
simulacrum Agent,Cognitive Modules - Conversation Session,Open conversation session in whisper mode,open_convo_session(persona, convo_mode) -> JSON
simulacrum Agent,Persona Hyperparameters - Vision Parameters,Define vision parameters for a persona,vision_r: integer; att_bandwidth: integer; retention: integer -> JSON
simulacrum Agent,World Information - Perceived World State,Define variables to represent the perceived state of the world,curr_time: datetime; curr_tile: tuple; daily_plan_req: str -> JSON
simulacrum Agent,Persona Identity - Personal Information,Define variables representing the core identity of a persona,name: str; first_name: str; last_name: str; age: int -> JSON
simulacrum Agent,Reflection Variables - Concept Forgetting and Reflection Configuration,Define variables related to concept forgetting and reflection,concept_forget: int; daily_reflection_time: int; daily_reflection_size: int; overlap_reflect_th: int; kw_strg_event_reflect_th: int; kw_strg_thought_reflect_th: int -> JSON
simulacrum Agent,New Reflection Variables - Additional Reflection Configuration,Define additional variables for reflection,recency_w: int; relevance_w: int; importance_w: int; recency_decay: float; importance_trigger_max: int; importance_trigger_curr: int; importance_ele_n: int; thought_count: int -> JSON
simulacrum Agent,Persona Planning - Daily Requirements,Define variables for the persona's daily requirements,daily_req: list[str]; f_daily_schedule: list[list[str,int]]; f_daily_schedule_hourly_org: list[list[str,int]] -> JSON
simulacrum Agent,Current Action - Current Action Details,Define variables representing the current action being performed by the persona,act_address: str; act_start_time: datetime; act_duration: int; act_description: str; act_pronunciatio: str; act_event: tuple -> JSON
simulacrum Agent,Chatting - Conversation Details,Define variables representing ongoing conversations,chatting_with: str; chat: list[list[str,str]]; chatting_with_buffer: dict; chatting_end_time: datetime -> JSON
simulacrum Agent,Path Planning - Planned Path,Define variables for planned path execution,act_path_set: bool; planned_path: list[tuple[int,int]] -> JSON
simulacrum Agent,Act Execution - Plan Execution,Given a plan, execute the action by outputting the tile coordinate path and the next coordinate for the persona.,plan: str -> JSON ({"execution": {"next_coordinate": tuple, "pronunciation": str, "description": str}})
simulacrum Agent,Perception - Event Perception,Perceive events nearby the persona and save them to memory: {"type":"array","items":{"type":"object","properties":{"event_id":{"type":"string"},"subject":{"type":"string"},"predicate":{"type":"string"},"object":{"type":"string"},"description":{"type":"string"},"keywords":{"type":"array","items":{"type":"string"}},"poignancy":{"type":"number"},"embedding":{"type":"object"}},"required":["event_id","subject","predicate","object","description","keywords","poignancy","embedding"]}
simulacrum Agent,Current Action - Current Action Details, Define variables representing the current action being performed by the persona, act_address: str; act_start_time: datetime; act_duration: int; act_description: str; act_pronunciatio: str; act_event: tuple -> JSON
Simulacrum Agent,Reflect Module,Return a JSON object containing reflections generated by the persona: {"thought": {"act_address": "str", "act_start_time": "datetime", "act_duration": "int", "act_description": "str", "act_pronunciatio": "str", "act_event": "tuple -> JSON"}}
Simulacrum Agent,Retrieve Module,Return a JSON object containing retrieved events and thoughts by the persona,{"event": {"subject": "str", "predicate": "str", "object": "str", "description": "str", "recency": "float", "importance": "float", "relevance": "float"}}
Simulacrum Agent,Event Handling,Return a JSON object containing events on a specified tile: {"event": {"address": "str", "subject": "str", "predicate": "str", "object": "str"}}
Simulacrum Agent,Path Finding,Given a maze represented as a 2D list of characters, a start coordinate, an end coordinate, and a character representing collision blocks, find and return the shortest path between the start and end coordinates.
Simulacrum Agent,Path Finding,Given a maze represented as a 2D list of characters, a start coordinate, an end coordinate, and a character representing collision blocks, find and return a path that leads a persona to the closest of four target coordinates surrounding the end coordinate.
Simulacrum Agent,Path Finding,Given a maze represented as a 2D list of characters, a start coordinate, an end coordinate, and a character representing collision blocks, divide the path between the start and end coordinates into two equal-length segments and return each segment separately.
Simulacrum Agent,Spatial Memory Subgraph,"Return a JSON object representing the part of the world perceived by the agent with root, child, and leaf nodes: {""root"": {""cafe"": {""table"": ""state"", ""chair"": ""state""}, ""park"": {""bench"": ""state""}}, ""houses"": {""house1"": {""bedroom"": {""bed"": ""state""}}}}"
Simulacrum Agent,Temporal Memory Subgraph,"Return a JSON object representing the timeline of events experienced by the agent with chronological nodes and relationships"
Simulacrum Agent,Emotional Memory Subgraph,"Return a JSON object representing the emotional states of the agent over time, with nodes for different emotions and edges representing transitions"
Simulacrum Agent,Sensory Memory Subgraph,"Return a JSON object representing the sensory inputs perceived by the agent, with nodes for different senses and edges representing connections between them"
Simulacrum Agent,Episodic Memory Subgraph,"Return a JSON object representing specific episodes or experiences stored in the agent's memory, with nodes for events and relationships between them"
Simulacrum Agent,Conceptual Memory Subgraph,"Return a JSON object representing the agent's conceptual understanding of various topics, with nodes for concepts and connections between them"
Simulacrum Agent,Language Memory Subgraph,"Return a JSON object representing the agent's language knowledge and vocabulary, with nodes for words and relationships between them"
Simulacrum Agent,Social Memory Subgraph,"Return a JSON object representing the agent's social interactions and relationships, with nodes for individuals and connections between them"
Simulacrum Agent,Meta Memory Subgraph,"Return a JSON object representing the agent's awareness of its own memory processes and strategies, with nodes for metacognitive concepts and connections between them"
Simulacrum Agent,Spatial Memory Subgraph,"Return a JSON object representing the part of the world perceived by the agent with root, child, and leaf nodes: {""root"": {""cafe"": {""table"": ""state"", ""chair"": ""state""}, ""park"": {""bench"": ""state""}}, ""houses"": {""house1"": {""bedroom"": {""bed"": ""state""}}}}"
Task Dependency Graph,Initial Tasks,Identify Main Goals
Task Dependency Graph,Initial Tasks,Conduct Market Research
Task Dependency Graph,Initial Tasks,Create Product Prototype
Task Dependency Graph,Market Research Tasks,Determine Target Audience
Task Dependency Graph,Market Research Tasks,Analyze Competitors
Task Dependency Graph,Market Research Tasks,Identify Market Trends
Task Dependency Graph,Product Development Tasks,Design User Interface
Task Dependency Graph,Product Development Tasks,Develop Backend Functionality
Task Dependency Graph,Product Development Tasks,Test Prototype
Knowledge Graph,Conceptual Framework,"Develop a knowledge graph outlining the foundational principles of machine learning, including nodes for supervised learning, unsupervised learning, and reinforcement learning, with edges representing relationships between them."
Knowledge Graph,Ontology Construction,"Create a knowledge graph representing the taxonomy of living organisms, with nodes for different species and relationships indicating their evolutionary history."
Knowledge Graph,Network Analysis,"Construct a knowledge graph illustrating the relationships between individuals in a social network, with nodes for users and edges representing friendships or interactions."
Knowledge Graph,Event Timeline,"Generate a knowledge graph depicting the major events of the French Revolution, with nodes for key figures, battles, and political milestones, connected by temporal relationships."
Knowledge Graph,Medical Diagnosis,"Develop a knowledge graph representing symptoms, diseases, and treatments in the field of cardiology, with nodes for each condition and edges indicating diagnostic criteria and treatment options."
Knowledge Graph,Geographical Mapping,"Create a knowledge graph showcasing the geological features of the Grand Canyon, with nodes for rock formations, geological layers, and landmarks, interconnected by spatial relationships."
Knowledge Graph,Financial Modeling,"Construct a knowledge graph illustrating the flow of funds in a corporate financial system, with nodes for revenue streams, expenses, and investments, connected by financial transactions."
Knowledge Graph,Text Analysis,"Develop a knowledge graph analyzing the themes and characters in a novel, with nodes for each character, plot point, and theme, connected by narrative arcs and character relationships."
Knowledge Graph,Supply Chain Management,"Generate a knowledge graph representing the logistics of a global supply chain, with nodes for manufacturers, distributors, and retailers, interconnected by shipping routes and inventory levels."
Multi-Action Tasks,Frontline QA AI,"Return a JSON object containing tasks to update the QA dataset and create a new model iteration: {""text"": ""Update the QA dataset with the latest user feedback and create a new model iteration for testing."", ""task_action"": [{""id"": 23, ""method"": ""update_task"", ""waiting_on"": null, ""name"": ""Update QA dataset"", ""notes"": ""Incorporate user feedback into the QA dataset and prepare for model testing."", ""bucket"": ""QA"", ""project"": ""Frontline QA AI""}, {""id"": 24, ""method"": ""create_task"", ""waiting_on"": [23], ""name"": ""Create new model iteration"", ""notes"": ""Develop and test a new model iteration based on the updated dataset."", ""bucket"": ""Model Development"", ""project"": ""Frontline QA AI""}]}"
Multi-Action Tasks,Future of Programming,"Return a JSON object containing tasks to create a new feature branch, implement a feature, and submit a pull request: {""text"": ""Create a new feature branch in the repository, implement the requested feature, and submit a pull request for review."", ""task_action"": [{""id"": 25, ""method"": ""create_task"", ""waiting_on"": null, ""name"": ""Create feature branch"", ""notes"": ""Create a new feature branch in the repository for implementing the requested feature."", ""bucket"": ""Development"", ""project"": ""Future of Programming""}, {""id"": 26, ""method"": ""update_task"", ""waiting_on"": [25], ""name"": ""Implement feature"", ""notes"": ""Implement the requested feature in the feature branch."", ""bucket"": ""Development"", ""project"": ""Future of Programming""}, {""id"": 27, ""method"": ""create_task"", ""waiting_on"": [26], ""name"": ""Submit pull request"", ""notes"": ""Submit a pull request for review after implementing the feature."", ""bucket"": ""Code Review"", ""project"": ""Future of Programming""}]}"
Multi-Action Tasks,Personal Site,"Return a JSON object containing tasks to update homepage layout and optimize images: {""text"": ""Update the homepage layout to include a new section about recent projects and optimize images for faster loading."", ""task_action"": [{""id"": 28, ""method"": ""update_task"", ""waiting_on"": null, ""name"": ""Update homepage layout"", ""notes"": ""Add a new section about recent projects to the homepage layout."", ""bucket"": ""Web Development"", ""project"": ""Personal Site""}, {""id"": 29, ""method"": ""update_task"", ""waiting_on"": [28], ""name"": ""Optimize images"", ""notes"": ""Optimize images on the homepage for faster loading."", ""bucket"": ""Web Development"", ""project"": ""Personal Site""}]}"
Multi-Action Tasks,Nordic Hamstring Curls,"Return a JSON object containing tasks to schedule meeting and update exercise protocol: {""text"": ""Schedule a meeting with the physiotherapist to discuss the latest research findings and update the exercise protocol accordingly."", ""task_action"": [{""id"": 30, ""method"": ""create_task"", ""waiting_on"": null, ""name"": ""Schedule meeting with physiotherapist"", ""notes"": ""Arrange a meeting with the physiotherapist to discuss the latest research findings."", ""bucket"": ""Healthcare"", ""project"": ""Nordic Hamstring Curls""}, {""id"": 31, ""method"": ""update_task"", ""waiting_on"": [30], ""name"": ""Update exercise protocol"", ""notes"": ""Update the exercise protocol based on the discussion with the physiotherapist."", ""bucket"": ""Healthcare"", ""project"": ""Nordic Hamstring Curls""}]}"
Multi-Action Tasks,Finance,"Return a JSON object containing tasks to update financial report and prepare slides: {""text"": ""Update the quarterly financial report with the latest revenue figures and prepare slides for the upcoming board meeting."", ""task_action"": [{""id"": 32, ""method"": ""update_task"", ""waiting_on"": null, ""name"": ""Update financial report"", ""notes"": ""Incorporate the latest revenue figures into the quarterly financial report."", ""bucket"": ""Finance"", ""project"": ""Finance""}, {""id"": 33, ""method"": ""create_task"", ""waiting_on"": [32], ""name"": ""Prepare board meeting slides"", ""notes"": ""Create slides for the upcoming board meeting based on the updated financial report."", ""bucket"": ""Presentation"", ""project"": ""Finance""}]}"
Multi-Action Tasks,Purview Operations,"Return a JSON object containing tasks to deploy monitoring tool and configure alerts: {""text"": ""Deploy the latest version of the monitoring tool to the production environment and configure alerts for critical system metrics."", ""task_action"": [{""id"": 34, ""method"": ""create_task"", ""waiting_on"": null, ""name"": ""Deploy monitoring tool"", ""notes"": ""Deploy the latest version of the monitoring tool to the production environment."", ""bucket"": ""Operations"", ""project"": ""Purview Operations""}, {""id"": 35,






